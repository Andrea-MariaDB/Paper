From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 5 May 2020 21:23:34 -0700
Subject: [PATCH] No-Tick view distance implementation

Implements world view distance getters/setters

Per-Player is absent due to difficulty of maintaining
the diff required to make it happen.

diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 5bcf9cefc29eb20e2cfbfb49e2b2662ec394a87e..a696474b4bd0e32a26dadfbc1257580ee596f0c0 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -156,7 +156,8 @@ public class TimingsExport extends Thread {
                 pair("gamerules", toObjectMapper(world.getWorld().getGameRules(), rule -> {
                     return pair(rule, world.getWorld().getGameRuleValue(rule));
                 })),
-                pair("ticking-distance", world.getChunkProvider().playerChunkMap.getEffectiveViewDistance())
+                pair("ticking-distance", world.getChunkProvider().playerChunkMap.getEffectiveViewDistance()),
+                pair("notick-viewdistance", world.getChunkProvider().playerChunkMap.getEffectiveNoTickViewDistance())
             ));
         }));
 
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 46ac6d91422423f1e03b86d3efa3241f2599000d..6463d3e4837d032a35654a035f42b8a805e0e286 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -632,4 +632,9 @@ public class PaperWorldConfig {
         phantomIgnoreCreative = getBoolean("phantoms-do-not-spawn-on-creative-players", phantomIgnoreCreative);
         phantomOnlyAttackInsomniacs = getBoolean("phantoms-only-attack-insomniacs", phantomOnlyAttackInsomniacs);
     }
+
+    public int noTickViewDistance;
+    private void viewDistance() {
+        this.noTickViewDistance = this.getInt("viewdistances.no-tick-view-distance", -1);
+    }
 }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 9abef8550a89df5e15ac28de1a5549d064f29122..d18497a33dc53f6b465e659967bf8c98731c46c0 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -638,7 +638,8 @@ public final class MCUtil {
             });
 
             worldData.addProperty("name", world.getWorld().getName());
-            worldData.addProperty("view-distance", world.spigotConfig.viewDistance);
+            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.getEffectiveViewDistance());
+            worldData.addProperty("no-view-distance", world.getChunkSource().chunkMap.getRawNoTickViewDistance());
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig.keepLoadedRange);
             worldData.addProperty("visible-chunk-count", visibleChunks.size());
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 0147798c0285f64b8d767dfb2709d92f66ac72ef..9ebcfca10071cc42d4f1df02c25de5042c065f38 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -81,6 +81,18 @@ public class ChunkHolder {
     }
     // Paper end - optimise isOutsideOfRange
 
+    // Paper start - no-tick view distance
+    public final LevelChunk getSendingChunk() {
+        // it's important that we use getChunkAtIfLoadedImmediately to mirror the chunk sending logic used
+        // in Chunk's neighbour callback
+        LevelChunk ret = this.chunkMap.level.getChunkSource().getChunkAtIfLoadedImmediately(this.pos.x, this.pos.z);
+        if (ret != null && ret.areNeighboursLoaded(1)) {
+            return ret;
+        }
+        return null;
+    }
+    // Paper end - no-tick view distance
+
     public ChunkHolder(ChunkPos pos, int level, LevelLightEngine lightingProvider, ChunkHolder.LevelChangeListener levelUpdateListener, ChunkHolder.PlayerProvider playersWatchingChunkProvider) {
         this.futures = new AtomicReferenceArray(ChunkHolder.CHUNK_STATUSES.size());
         this.fullChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
@@ -240,7 +252,7 @@ public class ChunkHolder {
     }
 
     public void blockChanged(BlockPos blockposition) {
-        LevelChunk chunk = this.getTickingChunk();
+        LevelChunk chunk = this.getSendingChunk(); // Paper - no-tick view distance
 
         if (chunk != null) {
             byte b0 = (byte) SectionPos.blockToSectionCoord(blockposition.getY());
@@ -256,7 +268,7 @@ public class ChunkHolder {
     }
 
     public void sectionLightChanged(LightLayer type, int y) {
-        LevelChunk chunk = this.getTickingChunk();
+        LevelChunk chunk = this.getSendingChunk(); // Paper - no-tick view distance
 
         if (chunk != null) {
             chunk.setUnsaved(true);
@@ -338,9 +350,48 @@ public class ChunkHolder {
     }
 
     private void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
-        this.playerProvider.getPlayers(this.pos, onlyOnWatchDistanceEdge).forEach((entityplayer) -> {
-            entityplayer.connection.send(packet);
-        });
+        // Paper start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerViewDistanceBroadcastMap;
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = viewDistanceMap.getObjectsInRange(this.pos);
+        if (players == null) {
+            return;
+        }
+
+        if (onlyOnWatchDistanceEdge) { // flag -> border only
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+
+                int viewDistance = viewDistanceMap.getLastViewDistance(player);
+                long lastPosition = viewDistanceMap.getLastCoordinate(player);
+
+                int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - this.pos.x);
+                int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - this.pos.z);
+
+                if (Math.max(distX, distZ) == viewDistance) {
+                    player.connection.send(packet);
+                }
+            }
+        } else {
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+                player.connection.send(packet);
+            }
+        }
+
+        return;
+        // Paper end - per player view distance
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getOrScheduleFuture(ChunkStatus targetStatus, ChunkMap chunkStorage) {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index b509928429b90b06d1af575569885e590cef2216..112927d4ef75f547b1e269de4caa78b4d8224c48 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -57,12 +57,14 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkPacket;
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
+import net.minecraft.network.protocol.game.ClientboundSetChunkCacheRadiusPacket;
 import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.util.CsvOutput;
 import net.minecraft.util.Mth;
 import net.minecraft.util.profiling.ProfilerFiller;
@@ -144,7 +146,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private boolean modified;
     private final ChunkTaskPriorityQueueSorter queueSorter;
     private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> worldgenMailbox;
-    private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox;
+    public final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox; // Paper - private -> public
+    // Paper start
+    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mailboxLight;
+    public void addLightTask(ChunkHolder playerchunk, Runnable run) {
+        this.mailboxLight.tell(ChunkTaskPriorityQueueSorter.message(playerchunk, run));
+    }
+    // Paper end
     public final ChunkProgressListener progressListener;
     public final ChunkMap.ChunkDistanceManager distanceManager; public final DistanceManager getChunkDistanceManager() { return this.distanceManager; } // Paper - OBFHELPER
     private final AtomicInteger tickingGenerated;
@@ -219,6 +227,22 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobSpawnMap; // this map is absent from updateMaps since it's controlled at the start of the chunkproviderserver tick
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerChunkTickRangeMap;
     // Paper end - optimise PlayerChunkMap#isOutsideRange
+    // Paper start - no-tick view distance
+    int noTickViewDistance;
+    public final int getRawNoTickViewDistance() {
+        return this.noTickViewDistance;
+    }
+    public final int getEffectiveNoTickViewDistance() {
+        return this.noTickViewDistance == -1 ? this.getEffectiveViewDistance() : this.noTickViewDistance;
+    }
+    public final int getLoadViewDistance() {
+        return Math.max(this.getEffectiveViewDistance(), this.getEffectiveNoTickViewDistance());
+    }
+
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceBroadcastMap;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceTickMap;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceNoTickMap;
+    // Paper end - no-tick view distance
 
     void addPlayerToDistanceMaps(ServerPlayer player) {
         int chunkX = MCUtil.getChunkCoordinate(player.getX());
@@ -235,6 +259,19 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper start - optimise PlayerChunkMap#isOutsideRange
         this.playerChunkTickRangeMap.add(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE);
         // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - no-tick view distance
+        int effectiveTickViewDistance = this.getEffectiveViewDistance();
+        int effectiveNoTickViewDistance = Math.max(this.getEffectiveNoTickViewDistance(), effectiveTickViewDistance);
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTickMap.add(player, chunkX, chunkZ, effectiveTickViewDistance);
+            this.playerViewDistanceNoTickMap.add(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk 1 neighbour, and we need another 1 for sending those extra neighbours (as we require neighbours to send)
+        }
+
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.add(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need an extra neighbour to render the full view distance configured
+        player.needsChunkCenterUpdate = false;
+        // Paper end - no-tick view distance
     }
 
     void removePlayerFromDistanceMaps(ServerPlayer player) {
@@ -247,6 +284,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.playerMobSpawnMap.remove(player);
         this.playerChunkTickRangeMap.remove(player);
         // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - no-tick view distance
+        this.playerViewDistanceBroadcastMap.remove(player);
+        this.playerViewDistanceTickMap.remove(player);
+        this.playerViewDistanceNoTickMap.remove(player);
+        // Paper end - no-tick view distance
     }
 
     void updateMaps(ServerPlayer player) {
@@ -264,6 +306,19 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper start - optimise PlayerChunkMap#isOutsideRange
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE);
         // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - no-tick view distance
+        int effectiveTickViewDistance = this.getEffectiveViewDistance();
+        int effectiveNoTickViewDistance = Math.max(this.getEffectiveNoTickViewDistance(), effectiveTickViewDistance);
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTickMap.update(player, chunkX, chunkZ, effectiveTickViewDistance);
+            this.playerViewDistanceNoTickMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk 1 neighbour, and we need another 1 for sending those extra neighbours (as we require neighbours to send)
+        }
+
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need an extra neighbour to render the full view distance configured
+        player.needsChunkCenterUpdate = false;
+        // Paper end - no-tick view distance
     }
     // Paper end
 
@@ -371,6 +426,45 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 }
             });
         // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - no-tick view distance
+        this.setNoTickViewDistance(this.level.paperConfig.noTickViewDistance);
+        this.playerViewDistanceTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                if (newState.size() != 1) {
+                    return;
+                }
+                LevelChunk chunk = ChunkMap.this.level.getChunkSource().getChunkAtIfLoadedMainThreadNoCache(rangeX, rangeZ);
+                if (chunk == null || !chunk.areNeighboursLoaded(2)) {
+                    return;
+                }
+
+                ChunkPos chunkPos = new ChunkPos(rangeX, rangeZ);
+                ChunkMap.this.level.getChunkSource().addTicketAtLevel(TicketType.PLAYER, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                if (newState != null) {
+                    return;
+                }
+                ChunkPos chunkPos = new ChunkPos(rangeX, rangeZ);
+                ChunkMap.this.level.getChunkSource().removeTicketAtLevel(TicketType.PLAYER, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+            });
+        this.playerViewDistanceNoTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+        this.playerViewDistanceBroadcastMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                if (player.needsChunkCenterUpdate) {
+                    player.needsChunkCenterUpdate = false;
+                    player.connection.send(new ClientboundSetChunkCacheCenterPacket(currPosX, currPosZ));
+                }
+                ChunkMap.this.updateChunkTracking(player, new ChunkPos(rangeX, rangeZ), new Packet[2], false, true); // unloaded, loaded
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkMap.this.updateChunkTracking(player, new ChunkPos(rangeX, rangeZ), null, true, false); // unloaded, loaded
+            });
+        // Paper end - no-tick view distance
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -1191,15 +1285,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         completablefuture1.thenAcceptAsync((either) -> {
             either.mapLeft((chunk) -> {
                 this.tickingGenerated.getAndIncrement();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.getPlayers(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    this.playerLoadedChunk(entityplayer, apacket, chunk);
-                });
+                // Paper - no-tick view distance - moved to Chunk neighbour update
                 return Either.left(chunk);
             });
         }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
+            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable)); // Paper - diff on change, this is the scheduling method copied in Chunk used to schedule chunk broadcasts (on change it needs to be copied again)
         });
         return completablefuture1;
     }
@@ -1294,32 +1384,38 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
-    protected void setViewDistance(int watchDistance) {
-        int j = Mth.clamp(watchDistance + 1, 3, 33);
+    public void setViewDistance(int watchDistance) { // Paper - public
+        int j = Mth.clamp(watchDistance + 1, 3, 33); // Paper - diff on change, these make the lower view distance limit 2 and the upper 32
 
         if (j != this.viewDistance) {
             int k = this.viewDistance;
 
             this.viewDistance = j;
-            this.distanceManager.updatePlayerTickets(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunkMap.values().iterator();
+            this.setNoTickViewDistance(this.getRawNoTickViewDistance()); //Paper - no-tick view distance - propagate changes to no-tick, which does the actual chunk loading/sending
+        }
 
-            while (objectiterator.hasNext()) {
-                ChunkHolder playerchunk = (ChunkHolder) objectiterator.next();
-                ChunkPos chunkcoordintpair = playerchunk.getPos();
-                Packet<?>[] apacket = new Packet[2];
+    }
 
-                this.getPlayers(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = checkerboardDistance(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
+    // Paper start - no-tick view distance
+    public final void setNoTickViewDistance(int viewDistance) {
+        viewDistance = viewDistance == -1 ? -1 : Mth.clamp(viewDistance, 2, 32);
 
-                    this.updateChunkTracking(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+        this.noTickViewDistance = viewDistance;
+        int loadViewDistance = this.getLoadViewDistance();
+        this.distanceManager.setNoTickViewDistance(loadViewDistance + 2 + 2); // add 2 to account for the change to 31 -> 33 tickets // see notes in the distance map updating for the other + 2
+
+        if (this.level != null && this.level.players != null) { // this can be called from constructor, where these aren't set
+            for (ServerPlayer player : this.level.players) {
+                ServerGamePacketListenerImpl connection = player.connection;
+                if (connection != null) {
+                    // moved in from PlayerList
+                    connection.send(new ClientboundSetChunkCacheRadiusPacket(loadViewDistance));
+                }
+                this.updateMaps(player);
             }
         }
-
     }
+    // Paper end - no-tick view distance
 
     protected void updateChunkTracking(ServerPlayer player, ChunkPos pos, Packet<?>[] packets, boolean withinMaxWatchDistance, boolean withinViewDistance) {
         if (player.level == this.level) {
@@ -1327,7 +1423,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
 
                 if (playerchunk != null) {
-                    LevelChunk chunk = playerchunk.getTickingChunk();
+                    LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - no-tick view distance
 
                     if (chunk != null) {
                         this.playerLoadedChunk(player, packets, chunk);
@@ -1588,6 +1684,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end - optimise isOutsideOfRange
 
+    private boolean cannotLoadChunks(ServerPlayer entityplayer) { return this.skipPlayer(entityplayer); } // Paper - OBFHELPER
     private boolean skipPlayer(ServerPlayer player) {
         return player.isSpectator() && !this.level.getGameRules().getBoolean(GameRules.RULE_SPECTATORSGENERATECHUNKS);
     }
@@ -1615,13 +1712,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             this.removePlayerFromDistanceMaps(player); // Paper - distance maps
         }
 
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkPos chunkcoordintpair = new ChunkPos(k, l);
-
-                this.updateChunkTracking(player, chunkcoordintpair, new Packet[2], !added, added);
-            }
-        }
+        // Paper - broadcast view distance map handles this (see remove/add calls above)
 
     }
 
@@ -1629,7 +1720,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         SectionPos sectionposition = SectionPos.of((Entity) entityplayer);
 
         entityplayer.setLastSectionPos(sectionposition);
-        entityplayer.connection.send(new ClientboundSetChunkCacheCenterPacket(sectionposition.x(), sectionposition.z()));
+        // Paper - distance map handles this now
         return sectionposition;
     }
 
@@ -1674,6 +1765,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         int k1;
         int l1;
 
+        /* // Paper start - replaced by distance map
         if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
             k1 = Math.min(i, i1) - this.viewDistance;
             l1 = Math.min(j, j1) - this.viewDistance;
@@ -1682,36 +1774,36 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
-                    ChunkPos chunkcoordintpair = new ChunkPos(k2, l2);
-                    boolean flag3 = checkerboardDistance(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = checkerboardDistance(chunkcoordintpair, i, j) <= this.viewDistance;
+                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
+                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
+                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
 
-                    this.updateChunkTracking(player, chunkcoordintpair, new Packet[2], flag3, flag4);
+                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
                 }
             }
         } else {
-            ChunkPos chunkcoordintpair1;
+            ChunkCoordIntPair chunkcoordintpair1;
             boolean flag5;
             boolean flag6;
 
             for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
                 for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkPos(k1, l1);
+                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = true;
                     flag6 = false;
-                    this.updateChunkTracking(player, chunkcoordintpair1, new Packet[2], true, false);
+                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
                 }
             }
 
             for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
                 for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkPos(k1, l1);
+                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = false;
                     flag6 = true;
-                    this.updateChunkTracking(player, chunkcoordintpair1, new Packet[2], false, true);
+                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
                 }
             }
-        }
+        }*/ // Paper end - replaced by distance map
 
         this.updateMaps(player); // Paper - distance maps
 
@@ -1719,11 +1811,46 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     @Override
     public Stream<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
-        return this.playerMap.a(chunkPos.toLong()).filter((entityplayer) -> {
-            int i = b(chunkcoordintpair, entityplayer, true);
+        // Paper start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> inRange = this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkPos);
 
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
-        });
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<ServerPlayer> players = new java.util.ArrayList<>();
+        Object[] backingSet = inRange.getBackingSet();
+
+        if (onlyOnWatchDistanceEdge) { // flag -> border only
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+                int viewDistance = this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+                long lastPosition = this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
+
+                int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - chunkPos.x);
+                int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - chunkPos.z);
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
+                }
+            }
+        } else {
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+                players.add(player);
+            }
+        }
+        return players.stream();
+        // Paper end - per player view distance
     }
 
     public void addEntity(Entity entity) { // Paper - protected -> public
@@ -1881,7 +2008,48 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     }
 
-    private final void sendChunk(ServerPlayer entityplayer, Packet<?>[] apacket, LevelChunk chunk) { this.playerLoadedChunk(entityplayer, apacket, chunk); } // Paper - OBFHELPER
+    // Paper start
+    private static int getLightMask(final LevelChunk chunk) {
+        final ChunkSection[] chunkSections = chunk.getSections();
+        int mask = 0;
+
+        for (int i = 0; i < chunkSections.length; ++i) {
+            /*
+
+
+Lightmasks have 18 bits, from the -1 (void) section until the 17th (air) section.
+Sections go from 0..16. Now whenever a section is not empty, it can potentially change lighting for the section itself, the section below and the section above, hence the bitmask 111b, which is 7d.
+
+             */
+            mask |= (ChunkSection.isEmpty(chunkSections[i]) ? 0 : 7) << i;
+        }
+
+        return mask;
+    }
+
+    private static int getCeilingLightMask(final LevelChunk chunk) {
+        int mask = getLightMask(chunk);
+
+        /*
+         It is similar to get highest bit, it would turn an 001010 into an 001111 so basically the highest bit and all below.
+         We then invert this, so we'd have 110000 and compare that to the "main" chunk.
+         This is because the bug only appears when the current chunks lightmaps are higher than those of the neighbors, thus we can omit sending neighbors which are lower than the current chunks lights.
+
+         so TLDR is that getCeilingLightMask returns a light mask with all bits set below the highest affected section. We could also count the number of leading zeros and invert them, somehow.
+         @TODO: Implement Leafs suggestion
+         either use Integer#numberOfLeadingZeros or document what this bithack is supposed to be doing then
+         */
+        mask |= mask >> 1;
+        mask |= mask >> 2;
+        mask |= mask >> 4;
+        mask |= mask >> 8;
+        mask |= mask >> 16;
+
+        return mask;
+    }
+    // Paper end
+
+    public final void sendChunk(ServerPlayer entityplayer, Packet<?>[] apacket, LevelChunk chunk) { this.playerLoadedChunk(entityplayer, apacket, chunk); } // Paper - OBFHELPER
     private void playerLoadedChunk(ServerPlayer player, Packet<?>[] packets, LevelChunk chunk) {
         if (packets[0] == null) {
             packets[0] = new ClientboundLevelChunkPacket(chunk, 65535, chunk.world.chunkPacketBlockController.shouldModify(player, chunk, 65535)); // Paper - Anti-Xray - Bypass
@@ -2067,7 +2235,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         ChunkPos chunkcoordintpair = new ChunkPos(this.entity.xChunk, this.entity.zChunk);
                         ChunkHolder playerchunk = ChunkMap.this.getVisibleChunkIfPresent(chunkcoordintpair.toLong());
 
-                        if (playerchunk != null && playerchunk.getTickingChunk() != null) {
+                        if (playerchunk != null && playerchunk.getSendingChunk() != null) { // Paper - no-tick view distance
                             flag1 = ChunkMap.checkerboardDistance(chunkcoordintpair, player, false) <= ChunkMap.this.viewDistance;
                         }
                     }
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 91c672531087430c47365657a3219ab5980d3467..c9b4025f6c3d1be7bca2ff7337dd86e37d21b53e 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -269,8 +269,8 @@ public abstract class DistanceManager {
         return s;
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.playerTicketManager.updateViewDistance(viewDistance);
+    protected void setNoTickViewDistance(int i) { // Paper - force abi breakage on usage change
+        this.playerTicketManager.updateViewDistance(i);
     }
 
     public int getNaturalSpawnChunkCount() {
@@ -388,7 +388,7 @@ public abstract class DistanceManager {
 
         private void onLevelChange(long pos, int distance, boolean oldWithinViewDistance, boolean withinViewDistance) {
             if (oldWithinViewDistance != withinViewDistance) {
-                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, DistanceManager.PLAYER_TICKET_LEVEL, new ChunkPos(pos));
+                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, new ChunkPos(pos)); // Paper - no-tick view distance
 
                 if (withinViewDistance) {
                     DistanceManager.this.ticketThrottlerInput.tell(ChunkTaskPriorityQueueSorter.message(() -> {
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index e29c08350a4ce69dfc993e6803f198d101ea109f..09971b6762b1841a23ed3552f1591b6991d709b2 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -248,6 +248,8 @@ public class ServerPlayer extends Player implements ContainerListener {
 
     double lastEntitySpawnRadiusSquared; // Paper - optimise isOutsideRange, this field is in blocks
 
+    boolean needsChunkCenterUpdate; // Paper - no-tick view distance
+
     public ServerPlayer(MinecraftServer server, ServerLevel world, GameProfile profile, ServerPlayerGameMode interactionManager) {
         super(world, world.getSpawn(), world.getSharedSpawnAngle(), profile);
         this.respawnDimension = Level.OVERWORLD;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 485ab6a7bc8093ce4a545b2fc77cc90f33e3373e..e76b177e32a5e4698bb609c3e006bd0e580f28b5 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -250,7 +250,7 @@ public abstract class PlayerList {
         boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
 
         // Spigot - view distance
-        playerconnection.send(new ClientboundLoginPacket(player.getId(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), worlddata.isHardcore(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionType(), worldserver1.dimension(), this.getMaxPlayers(), worldserver1.spigotConfig.viewDistance, flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat()));
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), worlddata.isHardcore(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionType(), worldserver1.dimension(), this.getMaxPlayers(), worldserver1.getChunkSource().chunkMap.getLoadViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat())); // Paper - no-tick view distance
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
         playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -904,7 +904,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         LevelData worlddata = worldserver1.getLevelData();
         entityplayer1.connection.send(new ClientboundRespawnPacket(worldserver1.dimensionType(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), entityplayer1.gameMode.getGameModeForPlayer(), entityplayer1.gameMode.getPreviousGameModeForPlayer(), worldserver1.isDebug(), worldserver1.isFlat(), flag));
-        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.getChunkSource().chunkMap.getLoadViewDistance())); // Spigot // Paper - no-tick view distance
         entityplayer1.setLevel(worldserver1);
         entityplayer1.removed = false;
         entityplayer1.connection.teleport(new Location(worldserver1.getWorld(), entityplayer1.getX(), entityplayer1.getY(), entityplayer1.getZ(), entityplayer1.yRot, entityplayer1.xRot));
@@ -1372,7 +1372,7 @@ public abstract class PlayerList {
 
     public void setViewDistance(int viewDistance) {
         this.viewDistance = viewDistance;
-        this.broadcastAll(new ClientboundSetChunkCacheRadiusPacket(viewDistance));
+        //this.sendAll(new PacketPlayOutViewDistance(i)); // Paper - move into setViewDistance
         Iterator iterator = this.server.getAllLevels().iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index be4c79988429169567b92f93ee5175169829b7c7..eab4c083b399e7073f143af2fa9f0db38dcb9a11 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -525,8 +525,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 this.setBlocksDirty(blockposition, iblockdata1, iblockdata2);
             }
 
-            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
+            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement // Paper - diff on change, see below
                 this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
+                // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
+                // if copied from above
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) {
+                ((ServerLevel)this).getChunkSource().blockChanged(blockposition);
+                // Paper end - per player view distance
             }
 
             if ((i & 1) != 0) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 8a14bdda4a408ec1e2b51efeb35467835f62b42c..dbea2a4370ccf24a5084cdabeecbc81f206e910a 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -27,9 +27,14 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.network.protocol.Packet;
 import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ChunkTaskPriorityQueueSorter;
 import net.minecraft.server.level.ServerChunkCache;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.TicketType;
 import net.minecraft.util.Mth;
 import net.minecraft.world.Container;
 import net.minecraft.world.entity.Entity;
@@ -242,7 +247,51 @@ public class LevelChunk implements ChunkAccess {
     }
 
     protected void onNeighbourChange(final long bitsetBefore, final long bitsetAfter) {
+        // Paper start - no-tick view distance
+        ServerChunkCache chunkProviderServer = ((ServerLevel)this.world).getChunkSource();
+        ChunkMap chunkMap = chunkProviderServer.chunkMap;
+        // this code handles the addition of ticking tickets - the distance map handles the removal
+        if (!areNeighboursLoaded(bitsetBefore, 2) && areNeighboursLoaded(bitsetAfter, 2)) {
+            if (chunkMap.playerViewDistanceTickMap.getObjectsInRange(this.coordinateKey) != null) {
+                // now we're ready for entity ticking
+                chunkProviderServer.mainThreadProcessor.execute(() -> {
+                    // double check that this condition still holds.
+                    if (LevelChunk.this.areNeighboursLoaded(2) && chunkMap.playerViewDistanceTickMap.getObjectsInRange(LevelChunk.this.coordinateKey) != null) {
+                        chunkProviderServer.addTicketAtLevel(TicketType.PLAYER, LevelChunk.this.chunkPos, 31, LevelChunk.this.chunkPos); // 31 -> entity ticking, TODO check on update
+                    }
+                });
+            }
+        }
 
+        // this code handles the chunk sending
+        if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
+            if (chunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(this.coordinateKey) != null) {
+                // now we're ready to send
+                chunkMap.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(chunkMap.getUpdatingChunkIfPresent(this.coordinateKey), (() -> { // Copied frm PlayerChunkMap
+                    // double check that this condition still holds.
+                    if (!LevelChunk.this.areNeighboursLoaded(1)) {
+                        return;
+                    }
+                    com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> inRange = chunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(LevelChunk.this.coordinateKey);
+                    if (inRange == null) {
+                        return;
+                    }
+
+                    // broadcast
+                    Object[] backingSet = inRange.getBackingSet();
+                    Packet[] chunkPackets = new Packet[2];
+                    for (int index = 0, len = backingSet.length; index < len; ++index) {
+                        Object temp = backingSet[index];
+                        if (!(temp instanceof ServerPlayer)) {
+                            continue;
+                        }
+                        ServerPlayer player = (ServerPlayer)temp;
+                        chunkMap.sendChunk(player, chunkPackets, LevelChunk.this);
+                    }
+                })));
+            }
+        }
+        // Paper end - no-tick view distance
     }
 
     public final boolean isAnyNeighborsLoaded() {
@@ -1131,7 +1180,7 @@ public class LevelChunk implements ChunkAccess {
                     BlockState iblockdata = this.getBlockState(blockposition);
                     BlockState iblockdata1 = Block.updateFromNeighbourShapes(iblockdata, (LevelAccessor) this.world, blockposition);
 
-                    this.world.setBlock(blockposition, iblockdata1, 20);
+                    this.world.setBlock(blockposition, iblockdata1, 20 | 2); // Paper - We send chunks before they're ticking ready, so we need to notify here
                 }
 
                 this.postProcessing[i].clear();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index dadf4c85ebe76a8d47a1f55ccbc2562a92933bcd..f60c9d73d294261745a9460e3b111c6e1fa65775 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -31,6 +31,7 @@ import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
 import net.minecraft.server.level.DistanceManager;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.Ticket;
@@ -2532,10 +2533,39 @@ public class CraftWorld implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return world.spigotConfig.viewDistance;
+        return getHandle().getChunkSource().chunkMap.getEffectiveViewDistance(); // Paper - no-tick view distance
     }
     // Spigot end
 
+    // Paper start - per player view distance
+    @Override
+    public void setViewDistance(int viewDistance) {
+        if (viewDistance < 2 || viewDistance > 32) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        ChunkMap chunkMap = getHandle().getChunkSource().chunkMap;
+        if (viewDistance != chunkMap.getEffectiveViewDistance()) {
+            chunkMap.setViewDistance(viewDistance);
+        }
+    }
+
+    @Override
+    public int getNoTickViewDistance() {
+        return getHandle().getChunkSource().chunkMap.getEffectiveNoTickViewDistance();
+    }
+
+    @Override
+    public void setNoTickViewDistance(int viewDistance) {
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        ChunkMap chunkMap = getHandle().getChunkSource().chunkMap;
+        if (viewDistance != chunkMap.getRawNoTickViewDistance()) {
+            chunkMap.setNoTickViewDistance(viewDistance);
+        }
+    }
+    // Paper end - per player view distance
+
     // Spigot start
     private final org.bukkit.World.Spigot spigot = new org.bukkit.World.Spigot()
     {
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 8cbafad53d20366a36493f22160c4fa3e4ac3eaf..20d5da61fc0594e86c68ea8fb5ebe5517f27f126 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -4,6 +4,7 @@ import java.util.Collection;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerChunkCache;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.FlyingMob;
@@ -192,7 +193,7 @@ public class ActivationRange
         maxRange = Math.max( maxRange, waterActivationRange );
         maxRange = Math.max( maxRange, villagerActivationRange );
         // Paper end
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        maxRange = Math.min( ( ((ServerLevel)world).getChunkSource().chunkMap.getEffectiveViewDistance() << 4 ) - 8, maxRange ); // Paper - no-tick view distance
 
         for ( Player player : world.players() )
         {
